> 데이터 Data :  현실 세계에서 수집된 사실
정보 : 데이터를 가공한(정보처리한) 결과물

데이터 종류
① 정형 데이터 : 구조화된 데이터 / 미리 정해진 구조에 따라 저장된 데이터 → ex) 스프레드시트, 테이블 
② 반정형 데이터 : 구조에 따라 저장된 데이터 / 구조 파악하는 파싱과정 필요함 → ex) HTML, XML, JSON
③ 비정형 데이터 : 정해진 구조 없이 저장된 데이터 → ex) 텍스트, 영상, 이미지, PDF, Word 


> 데이터베이스 Database : 데이터를 저장하고 관리하다가 필요시 제공해주는 역할을 하는 시스템
	→  조직에서 필요한 데이터를 공유하고 사용할 수 있도록 통합해 저장한 운영 데이터의 집합

DataWare House : 조직의 주요 업무 시스템에서 추출되어 새로 생성된 DB


데이터 사전 (=시스템 카탈로그) : 시스템 그 자체에 관련이 있는 스키마 및 다양한 객체에 관한 정보를 포함하는 시스템 DB


메타 데이터 Meta Data : 데이터 사전에 저장된 정보
		→ 데이터가 DB 시스템에서 읽혀지고 수정되기 전에 참조되는 파일

DB의 특징
① 실시간 접근
② 계속적인 변화
③ 동시 공유
④ 내용 기반 참조


DB 구조
① 외부단계 : 일반 사용자 관점  → 외부 스키마 (여러개 존재)
② 개념단계 : 조직 전체 관점 → 개념 스키마 (하나 존재)
③ 내부단계 : 저장 장치 관점 → 내부 스키마 (하나 존재)


DB 설계 
① 요구 분석  
② 개념적 설계 : 트랜잭션 모델링 수행
③ 논리적 설계 : 개념 스키마 평가, 정제 / 트랜잭션 인터페이스 설계
④ 물리적 설계 : 파일 조직 방법, 접근 방법 등 선정 
⑤ 데이터베이스 구현

→ 중요한 점 : 무결성, 일관성, 보안성 유지


DB 사용자 
① 일반 사용자 (최종 사용자) : DB에 접근해 데이터를 조작(삽입, 수정, 삭제) 하는 사람 → DML 주로 사용
② 응용 프로그래머 : 데이터 언어를 사용해 응용 프로그램을 작성하는 사용자 → DDL 주로 사용
③ DBA (DB 관리자) : 사용자를 위해 DB를 설계, 구축, 제어하는 사람 → DDL, DCL 주로 사용


DB 데이터 언어
① DDL (Data Definition Language) 데이터 정의어 : 데이터를 정의하고 변경하고 삭제 (CREATE / ALTER / DROP)
② DML (Data Manipulation Language) 데이터 조작어 : 데이터를 선택하고 추가하고 수정하고 식제 (SELECT / INSERT / UPDATE / DELETE)
③ DCL (Data Control Language) 데이터 제어어 : (COMMIT / ROLLBACK / GRANT / REVOKE)


무결성 vs 보안
- 무결성 Integrity : 권한 있는 사용자로부터 DB 보호 / DB를 정확히 사용할 수 있도록 보장함
- 보안 Security : 권한 없는 사용자로부터 DB 보호 / 사용자가 사용하고자할 때 사용할 수 있도록 보장함


> DBMS ; Database Management System : 기존 DB의 종속성, 중복성 문제를 해결하기 위해 제시된 DB 관리 소프트웨어

DBMS 구성
① 질의처리기 Query Processor : 사용자의 데이터 처리 요구를 해석하여 처리
	- DDL 컴파일러
	- DML 컴파일러
	- DML 프리 컴파일러 : 응용 프로그램에 삽입된 DML 추출해 DML 컴파일러로 전달
	- 런타임 DB 처리기 : DML 컴파일러로부터 전달받은 데이터 처리 요구를 DB에서 실행
	- 트랜잭션 관리자 : DB 접근 과정에서 사용자 접근 유효성 검사, 제약조건 위반 여부 검사
② 저장 데이터 관리자 : 저장된 DB와 데이터 사전 관리하고 접근하는 역할

DBMS 필수 기능
① 정의 
② 조작
③ 제어



> 데이터 모델링 Data Modeling : 현실 세계의 데이터를 이해하고 유형화, 구조화하는 과정


데이터모델링의 3단계 진행 (추상화의 과정)
① 개념적 데이터 모델링 
② 논리적 데이터 모델링
③ 물리적 데이터 모델링


모델링은 '추상화' '단순화' '명확화'의 과정이다.


데이터 모델 Data Model : 현실 세계의 데이터 구조를 컴퓨터 세계로 논리적으로 표현한 것 (=추상화)


데이터 모델 종류
- 개념적 데이터 모델 :  현실 데이터를 객체, 관계 정의한 것 / 개념적 데이터 모델링의 결과
		→ E-R Model, E-R Diagram
	
	* E-R Model (객체 - 관계 모델) : 현실 세계를 개념적으로 표현한 것 
	* E-R Diagram : 객체-관계 모델을 이용해 현실세계를 개념적으로 모델링한 결과를 그림으로 표현한 것 


- 논리적 데이터 모델 : 개념적 데이터를 객체, 관계 정의해 DB 구조로 표현한 것 / 논리적 데이터 모델링의 결과
		→ 데이터간의 관계에 따라 구분됨
			- 관계형 데이터 모델
			- 계층형 데이터 모델
			- 망형 데이터 모델 
	
	* 관계형 데이터 모델 : 논리적 데이터 모델에서 데이터 간의 관계를 PK, FK 등으로 표현하는 데이터 모델
	* 계층형 데이터 모델 : DB를 계층적 트리 구조로 표현, 1:N 관계
	* 망형 데이터 모델 : 논리적 구조 표현을 그래프 형태로 표현, 오너-멤버 관계    

데이터 모델 구조
- 엔터티 Entity : 조직에 필요한 어떤 객체 (=인스턴스의 집합)
	→ 식별성, 속성, 관계

- 속성 Attribute : 데이터의 가장 작은 논리적 단위
	→ 원자성, 도메인 (속성값의 범위)
	→ 한개의 엔터티는 두개 이상의 속성을 가짐
	→ 한개의 속성은 두개 이상의 속성값을 가짐
	→ 속성이 다중값일 경우 분리함

- 관계 Relationship : RDBMS 에서의 가장 큰 특징
	→ 관계 표기 ① 관계명 
		② 관계 차수 (1:1 / 1:N / N:M)
		③ 관계 선택 (필수 / 선택)


+ 식별자 : 엔터티를 대표할 수 있는 속성
	→ 유일성, 최소성, 불변성, 존재성
	
* 식별자 : 강한 연결 / 주식별자 포함 → 부모 상속
 비식별자 : 약한 연결 / 일반 속성 포함 → 자식과 부모 구분

엔터티 분류
- 유형 엔터티
- 개념 엔터티
- 사건 엔터티

- 기본 엔터티
- 중심 엔터티
- 행위 엔터티


속성 분류
- 기본 속성
- 설계 속성
- 파생 속성

- 일반 속성
- PK
- FK


관계 분류
- ERD → 존재 / 행위
- UML → 연관 / 의존


식별자 분류
- 주식별자 
- 보조 식별자

- 단일 식별자
- 복합 식별자

- 내부 식별자
- 외부 식별자

- 본질 식별자
- 인조 식별자


좋은 데이터 모델의 조건
① 완전성
② 중복배제
③ 데이터 재사용
④ 통합성


> 관계 데이터 모델 
- 릴레이션 Relation : 데이터들을 표 형태 (테이블)로 표현 
- 투플 Tuple : 릴레이션을 구성하는 행 (=레코드, 로우)  → 무순서성, 독립성
- 속성 Attribute : 테이블의 열, 원자값 (=컬럼)  → 무순서성, 고유성
- 도메인 Domain : 속성이 가질 수 있는 값의 범위
- 카디널리티 Cardinarity : 투플의 수
- 차수 Degree : 속성의 수 


키 Key : 릴레이션에서 투플들을 유일하게 구별하는 속성

키의 종류
① 슈퍼키 Super Key : 유일성을 만족하는 속성
② 후보키 Candidate Key : 유일성과 최소성을 만족하는 속성
③ 기본키 Primary Key : 후보키 중 기본적으로 사용하는 키 (=식별자)
④ 대체키 Alternate Key : 기본키 외 후보키
⑤ 외래키 Foreign Key : 다른 릴레이션의 기본키를 참조하는 속성


데이터 모델의 특징
- 개체 무결성 : 기본키는 Null 값, 중복값 불가
- 참조 무결성 : 외래키는 참조할 수 없는 값 불가



> 관계 데이터 연산
- 관계 대수 : 절차적 언어 (What + How)
- 관계 해석 : 비절차적 언어 (What)


관계 대수 : 데이터 조작을 위한 연산 집합 
- 일반 집합 연산자 - 합집합
		- 교집합
		- 차집합
		- 카티션 프로덕트

- 순수 관계 연산자 - SELECT 
		- PROJECT
		- JOIN
		- DIVISION

관계 해석 : "원하는 정보=?" 정의
- 투플 관계 해석
- 도메인 관계 해석

> SQL : 관계 DB를 위한 표준 질의어

내장 SQL : 응용 프로그램이 실행될 때 함께 실행됨
	→ 주 언어 변수와 DB 필드의 이름이 같아도 됨
	→ DB 필드의 SQL 데이터 타입과 일치해야 함
	→ 수행 결과로 단 하나의 투플만  반환됨


뷰 View : 가상 테이블
	→ 물리적이 아닌 논리적인 데이터
	→ SELECT는 자유롭지만 INSERT, DELETE, UPDATE는 제약이 있음
	→ 실제 데이터는 저장되지 않음
	→ 뷰안의 뷰 생성 가능 /  관련 뷰 삭제하면 연쇄 삭제됨
	→ 접근 제한에 보안
	→ 사용자에 따른 관리용




> 정규화 Normalization : 하나의 릴레이션을 여러 개의 릴레이션으로 분해 (분해해서 중복성 제거하기)
		→ 속성간의 중복성, 종속성 피하기 위함
		→ 삽입, 삭제, 수정, 이상의 발생 방지
		→ 데이터 구조 안정성 최대화


이상 Anomaly : 정규화를 거치지 않은 DB 내 데이터 중복 문제로 관계 연산을 처리할 때 발생하는 곤란한 현상
- 삽입 이상 : 데이터를 삽입할 때 원하지 않은 값도 같이 삽입되는 현상
- 삭제 이상 : 한 투플을 삭제할 때 연쇄 삭제 현상으로 인한 정보 손실 현상
- 갱신 이상 : 투플의 속성값을 갱신(수정)할 때 일부 투플의 정보만 갱신되어 정보의 모순이 발생하는 현상


함수적 종속 관계 : "Y는 X에 함수 종속적이다" = X → Y
- 이행적 함수 종속 = X → Y
		    Y → Z
		    X → Z
	

정규화 과정

    [ 비정규형 릴레이션 ] ↓ 정규화 시작
① 제 1 정규형 (1NF) : 도메인이 원자값 
-----------------------------------------------------------------  모든 속성의 도메인이 원자값으로만 구성
② 제 2 정규형 (2NF) : 부분 함수적 종속 제거
----------------------------------------------------------------- 모든 속성이 기본키에 완전 함수 종속적
③ 제 3 정규형 (3NF) : 이행적 함수 종속 제거
----------------------------------------------------------------- 모든 속성이 기본키에 이행적 함수 종속 아님
④ 보이스 / 코드 정규형 (BCNF) : 결정자이면서 후보키가 아닌것 제거
	= 강한 제 3 정규형
----------------------------------------------------------------- 모든 결정자가 후보키
⑤ 제 4 정규형 (4NF) : 다치 종속 제거
⑥ 제 5 정규형 (5NF) : 조인 종속성 이용


> 성능 데이터 모델링 : DB 성능 향상을 목적으로 하는데이터 모델링

성능 데이터 모델링 절차
① 정규화 수행
② DB 용량 산정 수행
③ 트랜잭션 유형 파악
④ 반정규화 수행
⑤ PK / FK 성능 → 칼럼 순서 조정
⑥ 데이터 모델 검증



> 트랜잭션 Transaction : DB의 상태를 변화시키기 위해 논리적 기능을 수행하는 하나의 작업 단위
		→ 한번에 수행되어야 할 일렬을 연산 집합
		→ 하나의 트랜잭션은 commit / rollback 되어야 함

	
- 커밋 Commit : 트랜잭션 작업의 논리적 단위가 성공적으로 완료되었다고 알리는 연산자
- 롤백 Rollback : 트랜잭션 작업이 실행 실패되었음을 알리는 연산자 / 수행 결과를 원상 복구 시키는 연산자


트랜잭션의 특성
① 원자성 : 트랜잭션 연산은 DB에 모두 반영되거나 전혀 반영되지 않아야 함 (All or Noting)
② 일관성 : 트랜잭션 실행이 성공적으로 완료되면 DB는 일관성 있는 상태임
③ 독립성 : 트랜잭션 실행 중에 있는 연산의 중간 결과에 다른 트랜잭션이 접근할 수 없음
④ 영속성 : 트랜잭션이 일단 실행 완료되면 결과가 영구적임


트랜잭션의 상태
- Active : 트랜잭션이 실행 중
- Failed : 트랜잭션 실행 중 오류 / 중단
- Aborted : 트랜잭션 실행 실패 / 철회 = Rollback
- Partially Commited : 트랜잭션 마지막 연산까지 실행했지만 commit 직전 상태
- Commit : 트랜잭션 실행 완료


> 장애
- 트랜잭션 장애 : 트랜잭션 수행 오류
- 시스템 장애 : 하드웨어 결함
- 미디어 장애 : 디스크 장치 결함


> 회복 Recovery : 트랜잭션을 수행하는 도중 장애로 인한 손상된 DB를 이전 정상 상태로 복구시키는 작업

회복 연산
- 덤프 dump : DB 전체를 다른 저장장치에 주기적으로 복사하는 방법
- 로그 log : DB에서 변경 연산 실행될 때마다 데이터 변경 이전 값과 이후 값을 별도의 파일에 기록하는 방법

- 재실행 redo : DB 복사본 가져와 로그 이용해 발생직전 DB 상태로 복구 → 트랜잭션 완료 전 장애 발생한 경우
- 취소 undo : 로그 이용해 실행된 변경 연산 취소해 DB 원래 상태로 복구 → 트랜잭션 완료 후 장애 발생한 경우


회복 기법
- 로그 회복 기법
	- 지연 갱신 회복 기법
	- 즉시 갱신 회복 기법 
- 검사시점 회복 기법
- 그림자 페이징 회복 기법
- 미디어 회복 기법


병행 제어 Concurrency Control : 트랜잭션의 상호작용을 제어하는 것
	→ DB 일관성 유지 / DB 공유 최대화 	/ 사용자에 대한 응답 시간을 최소화 / 시스템 활용도 최대화

- 로킹 기법
- 타임 스탬프 기법
- 낙관적 기법


로킹 Locking : 주요 데이터의 엑세스를 상호 배타적으로 하는 것
	→ 로킹 단위가 낮아질 수록 로크 수 많아짐 = 오버헤드 커짐, 관리 복잡


* 2단계 로킹 규약 
- 확장 단계 : 새로운 Lock 수행
- 축소 단계 : 새로운 Unlock 수행

→ 직렬성 보장 but 교착상태 예방 못함


타임 스탬프 기법 : 동시 제어를 위한 직렬화 기법
	→ 트랜잭션 간 순서 미리 정함

트리거 Trigger : 테이블에 대한 이벤트에 반응해 자동으로 실행하도록 프로시저를 가동시키는 작업
		→ 데이터 작업 제한, 작업 기록, 변경 작업 감사


> 분산 DB : 하나의 시스템이지만 물리적으로 네트워크를 통해 연결된 사이트에 분산된 데이터베이스
	→ DB 설계 어려움 / 오류 발생 가능성 높음


분산 DB의 목적
① 위치 투명성 : 엑세스 하려는 DB의 물리적으로 저장된 실제 위치를 알 필요 없음
② 중복 투명성 : 중복 사실을 모르고도 데이터 처리가 가능함
③ 병행 투명성 : 다수의 트랜잭션들이 동시에 실현되더라도 결과에는 영향 없음
④ 장애 투명성 : 장애가 생겨도 트랜잭션 정확히 처리됨


